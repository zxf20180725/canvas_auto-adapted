<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="./js/draw_base.js"></script>
</head>
<body style="margin: 0;padding: 0;">
<canvas id="main" style="width:100%;height:100%;margin: 0;padding: 0;display: block"></canvas>
<script>
    /*
        屏幕自适应解决方案1：
            1.指定游戏的一个标准分辨率，比如本游戏中就使用640*900
            2.获取屏幕的长宽：screenW,screenH
            3.设置canvas的宽高为screenW,screenH
            4.屏幕宽度与游戏标准宽度的比值：k=screenW/640
            5.计算出canvas可用区域的长度：900*k
            6.计算绘图的y轴偏移量：dY=(ScreenH-900*k)/2

        屏幕自适应解决方案2：
            与1的步骤基本相同，但是在绘制图片时，使用双缓冲，这样就不需要多次换算

       根据上面的计算，我们绘图的时候需要按一定比例缩放：
       drawImg(x,y+dY,w*k,h*k)
     */
    let canvas = document.getElementById("main");
    let ctx = canvas.getContext("2d");
    let screenW = document.documentElement.clientWidth;     //屏幕宽度
    let screenH = document.documentElement.clientHeight;    //屏幕高度
    let gameW=640,gameH=1280;   //标准分辨率,也就是你开发时的分辨率 TODO:这里可以自行修改

    let kW=screenW/gameW;       //屏幕宽度与标准宽度的比值
    let kH=1;                   //屏幕高度与标准高度的比值

    //我们先根据宽度比例适配
    let dY = (screenH - gameH * kW) / 2;    //黑色区域的高度（紫色区域顶部与屏幕顶部的距离）
    //当dY小于0时，我们不得不把画面给纵向压缩了。不然部分内容就会到屏幕外面去了
    if (dY<0){
        dY=0;
        kH=screenH/gameH;
    }

    let scaleH = kW;    //高度缩放率，默认以宽度比例
    if (kH!==1){
        scaleH=kH;
    }

    //设置canvas的绝对大小与屏幕一致
    canvas.width = screenW;
    canvas.height = screenH;

    //缓冲区
    let canvasBuffer=document.createElement("canvas");
    let ctxBuffer=canvasBuffer.getContext("2d");
    //缓冲区使用标准分辨率
    canvasBuffer.width=gameW;
    canvasBuffer.height=gameH;

    let timer = setInterval(mainLoop, 32);      //60FPS
    let testImg = NewImage('./test.png', 200, 250); //测试图片

    //游戏主循环
    function mainLoop() {
        drawFillRect(ctx, '#000', 0, 0, canvas.width, canvas.height);   //给canvas刷上一层黑色背景~
        drawFillRect(ctxBuffer, '#FF00FF', 0, 0, gameW, gameH);     //给游戏区域刷上一层紫色背景~
        drawText(ctxBuffer, '#FFF', 25, '窗口width：' + screenW, 0, 0);
        drawText(ctxBuffer, '#FFF', 25, '窗口height：' + screenH, 0, 30);
        drawText(ctxBuffer, '#FFF', 25, 'kW：' + kW, 0, 60);
        drawText(ctxBuffer, '#FFF', 25, 'kH：' + kH, 0, 90);
        drawText(ctxBuffer, '#FFF', 25, 'dY：' + dY, 0, 120);

        drawSrcImg(ctxBuffer,testImg,100,100);
        drawText(ctxBuffer, '#000', 32, '柳逐霓', 150, 350);

        drawSrcImg(ctxBuffer,testImg,270,100);
        drawText(ctxBuffer, '#000', 32, '柳逐霓', 320, 350);

        drawSrcImg(ctxBuffer,testImg,530,100);
        drawText(ctxBuffer, '#000', 32, '柳逐霓', 580, 350);

        drawSrcImg(ctxBuffer,testImg,100,400);
        drawText(ctxBuffer, '#000', 32, '柳逐霓', 150, 650);

        drawSrcImg(ctxBuffer,testImg,100,700);
        drawText(ctxBuffer, '#000', 32, '柳逐霓', 150, 950);

        drawSrcImg(ctxBuffer,testImg,100,1000);
        drawText(ctxBuffer, '#000', 32, '柳逐霓', 150, 1250);

        //双缓冲
        ctx.drawImage(canvasBuffer, 0, 0, gameW, gameH, 0, dY, screenW, gameH * scaleH);
    }

</script>

</body>
</html>